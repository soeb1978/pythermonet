import numpy as np

from pythermonet.domain import AggregatedLoadInput, HeatPumpInput


def source_load_from_cop(
        heat_pump_load: float | np.ndarray, cop: float = 3,
        heating: bool = True
        ) -> float | np.ndarray:
    """
    Calculates the thermal load on the source given the heat pump
    load(s) and Coefficient Of Performance(COP).

    The thermal load on the source depends on whether the load is for
    heating or cooling. For heating the electricity usage adds to the
    supplied heat, and for cooling the source must also remove the heat
    generated by the electricity consumption

    - Heating: 'thermal_load = load * (1 - 1/COP)'
    - Cooling: 'thermal_load = load * (1 + 1/COP)'

    Parameters
    ----------
    heat_pump_load : float or array-like
        The total load on the heat pump(s) [W].

    cop : float or array-like, default=3.0
        The COP of the heat pump(s).

    heating : bool, default=True
        If True, calculates the heating network load.
        If False, calculates the cooling network load.

    Returns
    -------
    thermal_load : float or ndarray
        The portion of the thermal load that the source must provide or
        receive [W].
    """
    if heating:
        thermal_load = np.multiply(heat_pump_load, 1 - np.divide(1, cop))
    else:
        thermal_load = np.multiply(heat_pump_load, 1 + np.divide(1, cop))
    return thermal_load


def source_loads_all_timescales(
        model_file_input: AggregatedLoadInput | HeatPumpInput,
        heating: bool = True,
        ) -> float:
    """
    Calculates source thermal loads for all three time scales.

    This function wraps the 'source_load_from_cop' function to produce
    the thermal loads for yearly, seasonal, and peak time scales, either
    for heating or cooling mode.

    Parameters
    ----------
    model_file_input : AggregatedLoadInput or HeatPumpLoadInput
        Input data containing either the aggregate load or the
        individual heat pump loads and COP/EER values for the different
        time scales.

    heating : bool, default=True
        If True, calculates thermal load when the source supplies heat.
        If False, calculates thermal load when the source recieves heat.

    Returns
    -------
    loads : list of float
        A list containing the source thermal loads for the three time
        scales:
        - 'loads[0]': Yearly load [W]
        - 'loads[1]': Seasonal load [W]
        - 'loads[2]': Daily peak load [W]

    Notes
    -----
    - The simultaneity factor should be applied externally (only to the
      peak load) if relevant for your calculation.
    - This helper function is intended to be assigned directly to e.g.
      'aggLoad.P_s_H' or 'aggLoad.P_s_C' in your dimensioning workflow.
    """
    if isinstance(model_file_input, AggregatedLoadInput):
        if heating:
            return [
                source_load_from_cop(
                    model_file_input.load_yearly_heating,
                    model_file_input.cop_yearly_heating,
                    heating=heating
                ),
                source_load_from_cop(
                    model_file_input.load_winter_heating,
                    model_file_input.cop_winter_heating,
                    heating=heating
                ),
                source_load_from_cop(
                    model_file_input.load_daily_peak_heating,
                    model_file_input.cop_hourly_peak_heating,
                    heating=heating
                )
            ]
        else:
            return [
                source_load_from_cop(
                    model_file_input.load_yearly_cooling,
                    model_file_input.eer_cooling,
                    heating=heating
                ),
                source_load_from_cop(
                    model_file_input.load_summer_cooling,
                    model_file_input.eer_cooling,
                    heating=heating
                ),
                source_load_from_cop(
                    model_file_input.load_daily_peak_cooling,
                    model_file_input.eer_cooling,
                    heating=heating
                )
            ]
    if isinstance(model_file_input, HeatPumpInput):
        if heating:
            return [
                source_load_from_cop(
                    model_file_input.loads_yearly_heating,
                    model_file_input.cops_yearly_heating,
                    heating=heating
                ),
                source_load_from_cop(
                    model_file_input.loads_winter_heating,
                    model_file_input.cops_winter_heating,
                    heating=heating
                ),
                source_load_from_cop(
                    model_file_input.loads_daily_peak_heating,
                    model_file_input.cops_hourly_peak_heating,
                    heating=heating
                )
            ]
        else:
            return [
                source_load_from_cop(
                    model_file_input.loads_yearly_cooling,
                    model_file_input.eers_cooling,
                    heating=heating
                ),
                source_load_from_cop(
                    model_file_input.loads_summer_cooling,
                    model_file_input.eers_cooling,
                    heating=heating
                ),
                source_load_from_cop(
                    model_file_input.loads_daily_peak_cooling,
                    model_file_input.eers_cooling,
                    heating=heating
                )
            ]


def mass_flow_from_load(
        load: float, delta_temp: float, density: float, heat_capacity: float
        ) -> float:
    """
    Calculates the mass flow rate required to handle the specified
    thermal load, given the fluid properties and the temperature
    difference across the heat pump.

    Parameters
    ----------
    load : float
        The thermal load [W].

    delta_temp : float
        The temperature difference across the heat pump [K or °C].

    density : float
        Density of the fluid [kg/m³].

    heat_capacity : float
        Specific heat capacity of the fluid [J/(kg·K)].

    Returns
    -------
    mass_flow : float
        Required mass flow rate [kg/s].
    """
    mass_flow = load / (delta_temp * density * heat_capacity)
    return mass_flow


def flow_velocity_from_mass_flow(
        mass_flow: float | np.ndarray,
        pipe_inner_diameter:  float | np.ndarray,
        ) -> float | np.ndarray:

    return np.divide(4 * mass_flow, np.pi * pipe_inner_diameter**2)


def pipe_inner_diameter(
        outer_diameter: float | np.ndarray, SDR: float | np.ndarray = 17.0
        ) -> float | np.ndarray:
    """
    Calculates the inner pipe diameter given the outer diameter and the
    SDR

    Args
    :param outer_diameter: The outer diameter of the pipes
    :type  outer_diameter: float or list of floats
    :param SDR: The surface to diameter ratio of the pipe
    :type  SDR: float or list of floats

    Return
    :param -: The inner diameter of the pipes
    :type  -: float or list of floats

    """
    return np.multiply(outer_diameter, (1. - np.divide(2., SDR)))


def pipe_brine_volume(
        pipe_length: float | np.ndarray, 
        pipe_inner_diameter: float | np.ndarray
        ) -> float | np.ndarray:
    
    return np.multiply(pipe_length * np.pi / 4, pipe_inner_diameter**2)